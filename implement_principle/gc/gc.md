### Go 垃圾回收

主流的垃圾回收算法有两类：追踪式垃圾回收算法和引用计数法。Go语言使用的三色标记法属于追踪式垃圾回收算法的一种

在应用程序中，主要分为堆和栈两种内存，GC 主要是对堆内存的回收。因为栈内存由编译器管理，这块内存用完后，会直接释放。

- 追踪式垃圾回收算法：是判断一个对象是否可达，当该对象不可达时，GC回收
- 引用计数法：当一个对象被引用时，计数加1，后续每被引用一次，计数累积加1；当引用释放时，计算减1，直到计数为0 ，GC回收

##### Go 采用三色标记清除算法 + 混合写屏障

颜色含义

- 白色对象集合：潜在的垃圾对象，最后会被GC回收
- 黑色对象集合：最后保存下来的对象，包括根对象可达对象和没有引用外部指针(白色对象)的对象
- 灰色对象集合：存在指向白色对象的外部指针，GC会扫描这些对象，直到灰色对象集合为空

具体实现流程：

- 初始化时，将所有对象标记为白色对象
- 从根对象出发，扫描所有可达对象(包括全局变量以及栈、寄存器上的变量)；将它们标记成灰色，放入灰色对象队列
- 从队列中取出一个灰色对象并标记成黑色，将其引用的对象(白色)标记为灰色，放入到灰色队列中
- 重复上一步骤，直到灰色对象队列为空
- 最后白色集合剩下的都是垃圾对象

在v1.8，使用插入写屏障和删除写屏障构成混合写屏障，实现并发和增量垃圾回收机制，无需STW

写屏障主要是保证三色不变性：强三色不变性和弱三色不变性

混合写屏障：是实现了变相的弱三色不变性

在GC标记阶段，该写屏障会将被覆盖的指针标记成灰色(删除写屏障)并在当前栈没有扫描时将新指针也标记成灰色(插入写屏障)；
并将所有新建的对象直接标记成黑色。

例如：在GC运行时，Goroutine中已被标记成黑色的对象A，引用了一个新对象F；因为本次GC已标记过的黑色对象不会再次扫描，
所以F对象会被当作白对象回收。而写屏障就是此时发挥作用，修改原先的写逻辑，将F对象改成灰色，使其正常使用。

##### GC 触发的时机

- 超过内存的阈值。当堆上的已分配内存是上次GC结束后存活对象的所用内存的2倍(默认，可根据GOGC环境变量调整)时，会触发GC
- 定时调用GC。当一直达不到内存的阈值时，runtime.sysmon 在监测一段时间(默认2分钟)后，触发新的GC回收
- 人为强制执行GC，调用runtime.GC()方法

##### GC 调优

GC 在运行时，会占用系统的资源。对于频繁分配内存的程序，会增加GC的工作量，频繁的消耗CPU。

当GC回收的速度低于标记对象的速度，GC 还会请求其他Goroutine协作，这个过程叫Mark assist。这样，其他Goroutine中正在执行的任务会被停滞，影响业务逻辑的进行。

调优的方向：

- 合理控制内存分配的速度。如：限制Goroutine的数量、或者分批创建Goroutine，分批执行
- 减少堆内存的分配。如：重复使用对象、少量使用`+` 连接字符串
- 调整GOGC环境变量。增大GOGC的值，降低GC回收频率


