### Go 内存分配原理
Go 的内存管理主要是借鉴Google中的内存分配器 TCMalloc 的思想

Go 中的内存管理主要分为栈区和堆区

1. 栈区

栈区主要是为代码中变量的声明，函数的调用等分配内存，由go的编译器管理自动进行分配和释放

Go 运行程序时，每个Goroutine都有各自的栈区，不需要加锁，是线程安全的

2. 堆区

堆区由编译器和开发工程师共同管理，并由GC回收

程序在运行期间，会主动从堆上申请内存，由内存分配器分配，当不需要时，再由GC回收

#### 对于堆区的内存分配

Go 在启动时，会向操作系统申请一大块内存(虚拟内存)，分配到堆和线程缓存中。当后续使用时，不必立即从操作系统申请内存。

**Go 的内存分配是多层级分配的，有以下几个概念**

![Go 内存管理流程图](/image/memory_allocation.jpg)

1.Page

是内存分配器向操作系统申请内存时的最小单位，大小是8K

2.span

是内存管理中的基本单位，由一段连续的Page组成，可以是一个Page，也可以是多个Page

3.span class

标识span的大小，从0~66共67级别，class = 0 是没有被使用的

4.mcache

线程缓存，微对象和小对象最先从这里分配内存。每个线程都有各自的mcache，是线程安全的，不需要加锁。

Go 中的线程个数与Go启动时的GOMAXPROCS对应（即逻辑处理器P）
mcache中有多个级别的span，区别span的大小。同一级别的span分两类：一类是可以被GC扫描的span，里面有包含指针的对象，空闲后会被回收；另一类是不包含指针的对象，不会被GC扫描到。

5.mcentral （central cache）

中心缓存，是多个线程的全局缓存，因为是多个线程共享，所以会出现并发情况，当申请内存时需要加锁。

中心缓存中也包含各个级别的span，这里分为两种span list,一种是empty链表，标识已被分配了对象或者是已被对应的线程占用；另一种是nonempty表，可以被分配内存。

6.mheap (页堆)

Go 程序的堆空间，管理所有的中心缓存，申请内存时需要加锁。

当mheap中内存不够时，会直接向操作系统申请内存(以Page为单位申请)，mheap中存储span不再是链表的形式，而是两颗树的结构。

一种是free树，是从操作系统申请的，一种是scav，是GC回收的。mheap会优先从scav中分配，无则从free中分配。若两者都没有空闲的，则会向操作系统申请新的内存，之后再次遍历这两颗二叉树，分配内存。

在mheap中有多个heapArena，heapArena存储连续的span，管理span，包括地址的映射和标识span是否包含指针对象(GC回收)。

**在申请内存时，分为微对象(tiny)、小对象、大对象**

1. 微对象(1Byte~16Byte)

对于微对象，mcache中提供专门的Tiny allocator对其分配，微对象是不包含指针的，例如一些小的字符串和独立转移变量。

分配原则：
在为微对象分配内存之前，先查看上一次分配的元素中是否有内存空间，如果不够，再分配下个空闲的内存块。

2. 小对象(16Byte~32KB)

小对象先向mcache申请内存，当mcache内存不够时，会向central cache申请内存空间，若mcentral没有足够内存时，
会向mheap申请，直到从操作系统中申请新的内存块。

分配原则：

当mache中没有足够内存时，会向mcentral中申请：

获取加锁：此时先从nonempty链表中找到空闲的span，并把它从nonempty中删除；将取出的span然后放入到empty链表中，
，最后将此span返回给工作线程，解锁。

归还加锁：先将span从empty链表中删除，然后放入到nonempty链表，解锁。

3. 大对象(大于32KB)

对于大对象，会直接从mheap上申请大小对应的内存块(因为mcache和mcentral无法堆管理超过32KB的内存分配)

**总结:**
1. Go 在启动时，会先向操作系统申请一大块虚拟内存(减少系统调用)，由heap全局管理，存储在堆上(heapArena)。
2. 在分配内存时，以span为基本单位，根据对象需要内存的大小，分配不同级别的span，减少内存碎片。
3. 工作线程首先会使用本地缓存(mcache)，当本地缓存空间不够时，会向central cache(全局缓存)申请。
4. 当工作线程释放内存时，会把申请的内存返还到对应的存储空间，以便复用。




